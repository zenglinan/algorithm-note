## 插入排序
### 实现原理
1. 从第一个元素开始，该元素被认为是已排序元素<br>
2. 取出下一个元素，在已经排序的元素序列中从后向前扫描
3. 如果未排序元素比较小，将两个元素交换位置<br>
4. 重复步骤3，直到找到正确的位置(比前一个大)
5. 重复2-4，直到最后一个元素排序完成

```
function insertSort(arr) {
  const len = arr.length
  if(len === 1) return arr
  for (let i = 1; i <= len - 1; i++) {
    for (let j = i - 1; j >= 0; j--) {  // j为已排序元素的末数
      if (arr[j + 1] < arr[j]) {  // 只要比前一个小，就交换位置
        [arr[j + 1], arr[j]] = [arr[j], arr[j + 1]]
      }
    }
  }
  return arr
}
```
## 二分插入排序
通过二分查找，可以适当减少比较次数
### 实现原理
取出要插入的第i个元素，对前面的 0～i-1 元素进行折半，先跟他们中间的那个元素比，如果小，<br>
则对前半再进行折半，否则对后半进行折半，直到left<right，<br>
此时，left就是元素最终应去的索引位置。<br>
然后再通过splice方法插入元素即可。
```
function bindaryInsertSort(arr) {
  let len = arr.length
  if (len === 1) return arr
  
  for (let i = 1; i <= len - 1; i++) {
  
    let tmp = arr.splice(i,1)[0],  // 取出要排序的那个元素
    left = 0, right = i - 1,
    middleIndex  // 中间索引
    
    while(left <= right){  // 二分查找
      middleIndex = parseInt((left + right)/2)
      if(tmp < arr[middleIndex]){  // 不断缩小范围, 最后得出的left值是要排序元素的位置索引
        right = middleIndex - 1
      }else {
        left = middleIndex + 1
      }
    }
    
    arr.splice(left,0,tmp)
  }
  return arr
}
```
