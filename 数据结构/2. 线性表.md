## 线性表
### 抽象数据类型定义
#### 元素关系
零个或多个元素的有限序列, 第一个元素只有后继, 末尾元素只有前驱, 中间的每个元素都有前驱后继
#### 线性表操作
1. 初始化线性表
2. 空判断
3. 清空线性表
4. 获取指定元素
5. 查找与给定值相同的元素
6. 插入元素
7. 删除元素
8. 返回元素个数
### 物理结构
#### 顺序存储结构: 数组
适合查找, 不适合频繁的插入删除操作(需要整体移动大量元素)<br>
在静态语言里, 需要指定存储空间大小
#### 链式存储结构: 链表
除了保存本位的值, 还需保存后继元素的地址<br>
适合频繁的增删(只需要改变节点指针指向), 不适合查找(必须从头开始一个个找)<br>
不需要指定存储空间大小
### 单链表
链表雏形
```asp
function Node(value) {
  this.data = value  // 节点存放的数据
  this.nextNode = null  // 下一个节点的地址
}

function SinglyList() {
  this.head = null  // 首节点默认为null
  this.len = 0  // 链表长度
}
```
增加链表节点的方法
```asp

SinglyList.prototype.addNode = function (value) {  // 传入的value为新建节点保存的数据
  let newNode = new Node(value)
  let currentNode = this.head

  if (!currentNode) {  // 一个节点都没有
    this.head = newNode
    this.len++
    return newNode
  }
  while (currentNode.nextNode) {  // 找出当前链表的最后一个节点
    currentNode = currentNode.nextNode  // 将currentNode从head节点不断后移
  }
  currentNode.nextNode = newNode  // 此时currentNode已经为最后一个节点, 将新节点接上
  this.len++
  return newNode
}
```
查找链表节点的方法
```asp
SinglyList.prototype.searchNode = function (position) {  // 传入需要查找的节点的位置
  let {len} = this
  let targetNode = this.head  // 从第一个开始找目标节点
  let index = 0
  if (len === 0 || position < 0 || position >= len) {
    throw new Error('non-existent node in this list')
  } else {
    while (index < position) {  // 找到position对应的节点
      targetNode = targetNode.nextNode
      index++
    }
    return targetNode
  }
}
```
删除链表节点的方法
```asp
SinglyList.prototype.removeNode = function (position) {  // position为节点索引, 从0开始
  let {len} = this
  let currentNode = this.head
  let preNode, nextNode, toDeleteNode
  let index = 0
  if (len === 0 || position >= len || position < 0) {
    throw new Error('non-existent node in this list')
  } else if (position === 1) {
    toDeleteNode = this.head
    this.head = toDeleteNode.nextNode
    toDeleteNode = null  // 释放节点
    return toDeleteNode
  } else {
    while (index < position) {
      preNode = currentNode
      currentNode = currentNode.nextNode
      toDeleteNode = currentNode
      nextNode = toDeleteNode.nextNode
      index++
    }
    preNode.nextNode = nextNode  // 将要删除的前一个节点指向要删除的后一个节点
    let returnNode = toDeleteNode  // 保存一下要被删除的元素, 留作返回值
    toDeleteNode = null  // 释放节点
    this.len--
    return toDeleteNode
  }
}
```
### 双向链表